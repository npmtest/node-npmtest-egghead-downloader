{"/home/travis/build/npmtest/node-npmtest-egghead-downloader/test.js":"/* istanbul instrument in package npmtest_egghead_downloader */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-egghead-downloader/lib.npmtest_egghead_downloader.js":"/* istanbul instrument in package npmtest_egghead_downloader */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_egghead_downloader = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_egghead_downloader = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-egghead-downloader/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-egghead-downloader && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_egghead_downloader */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_egghead_downloader\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_egghead_downloader.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_egghead_downloader.rollup.js'] =\n            local.assetsDict['/assets.npmtest_egghead_downloader.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_egghead_downloader.__dirname + '/lib.npmtest_egghead_downloader.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-egghead-downloader/node_modules/egghead-downloader/dist/app.js":"#! /usr/bin/env node\n'use strict';\n\nlet getCSRFToken = (() => {\n  var _ref = _asyncToGenerator(function* () {\n    const body = yield rp(SIGN_IN_URL);\n    const pattern = /<meta name=\"csrf-token\" content=\"(.*)\" \\/>/;\n    const [, CSRFToken] = pattern.exec(body) || [];\n    return CSRFToken;\n  });\n\n  return function getCSRFToken() {\n    return _ref.apply(this, arguments);\n  };\n})();\n\nlet authenticate = (() => {\n  var _ref2 = _asyncToGenerator(function* (email, password) {\n    const CSRFToken = yield getCSRFToken();\n    const options = {\n      method: 'POST',\n      uri: SIGN_IN_URL,\n      form: {\n        'user[email]': email,\n        'user[password]': password,\n        'authenticity_token': CSRFToken\n      },\n      simple: false,\n      resolveWithFullResponse: true\n    };\n\n    const response = yield rp(options);\n\n    if (response.statusCode !== 302) {\n      throw Error('Failed to authenticate.');\n    }\n  });\n\n  return function authenticate(_x, _x2) {\n    return _ref2.apply(this, arguments);\n  };\n})();\n\nlet doTheMagic = (() => {\n  var _ref3 = _asyncToGenerator(function* () {\n    if (program.email) {\n      if (program.password === true) {\n        const { password } = yield prompt({\n          type: 'password',\n          name: 'password',\n          message: 'Egghead.io password'\n        });\n        program.password = password;\n      }\n      try {\n        yield authenticate(program.email, program.password);\n        isPro = true;\n        success('Authenticated!');\n      } catch (err) {\n        return error(err);\n      }\n    }\n\n    const videos = yield getVideoData();\n    if (!videos.length) {\n      error('no video found!');\n    }\n    success(`Found ${ videos.length } ${ videos.length > 1 ? 'videos' : 'video' }`);\n\n    createOutputDirectoryIfNeeded();\n\n    const padLength = String(videos.length).length;\n    const padZeros = '0'.repeat(padLength);\n    let i = 0;\n    for (const { url, filename } of videos) {\n      i++;\n      let paddedCounter = `${ padZeros }${ i }`.slice(-padLength);\n      const p = path.join(outputDir, program.count ? `${ paddedCounter }-${ filename }` : filename);\n      if (!program.force && fileExists(p)) {\n        console.log(`File ${ paddedCounter }-${ filename } already exists, skip`);\n        continue;\n      }\n      progress.start(`Downloading video ${ paddedCounter } out of ${ videos.length }: '${ filename }'`);\n      const stream = fs.createWriteStream(p);\n      yield new Promise(function (resolve, reject) {\n        request(url).on('error', function () {\n          error(`download of '${ url }' failed!`, false);\n          reject();\n        }).on('end', function () {\n          resolve();\n        }).pipe(stream);\n      });\n      stream.close();\n      progress.stop(true);\n    }\n    success('Done!');\n  });\n\n  return function doTheMagic() {\n    return _ref3.apply(this, arguments);\n  };\n})();\n\n// loads the url and parses it, when it's playlist/serie loads the video pages\n// too, and returns an array with the video data\n\n\nlet getVideoData = (() => {\n  var _ref4 = _asyncToGenerator(function* () {\n    try {\n      const [, lessonSlug] = /egghead.io\\/lessons\\/([^\\?]*)/.exec(urlValue) || [];\n      let source = yield rp(urlValue);\n\n      if (lessonSlug) {\n        let videoData;\n        success('The URL is a lesson');\n\n        if (isPro) {\n          const response = yield rp({\n            uri: `https://egghead.io/api/v1/lessons/${ lessonSlug }/next_up`,\n            json: true\n          });\n          const { lessons } = response.list || { lessons: [] };\n\n          videoData = lessons.filter(function (lesson) {\n            return lesson.slug === lessonSlug;\n          }).map(function (lesson) {\n            const pattern = /https:\\/\\/.*\\/lessons\\/.*\\/(.*)\\?.*/;\n            const [url, filename] = pattern.exec(lesson.download_url);\n            return { url, filename };\n          })[0];\n        } else {\n          videoData = parseLessonPage(source);\n        }\n\n        // process the lesson page\n        if (videoData) {\n          return [videoData];\n        } else {\n          error(`failed to parse the lesson page '${ urlValue }'}`);\n        }\n      } else {\n        let lessonURLs = [];\n        success('The URL is a playlist or series');\n\n        // get the urls of the lessions\n        const re = /<h4 class=\"title\"><a href=\"(https:\\/\\/egghead.io\\/lessons\\/.+?)\">/g;\n        // regexp in js have no matchAll method or something similiar..\n        let match;\n        while (match = re.exec(source)) {\n          lessonURLs.push(match[1]);\n        }\n        success(`Found ${ lessonURLs.length } ${ lessonURLs.length > 1 ? 'lessons' : 'lesson' }`);\n\n        if (isPro) {\n          const firstLesson = lessonURLs[0];\n          const pattern = /egghead.io\\/lessons\\/(.*)\\?/;\n          const [, lessonSlug] = pattern.exec(firstLesson) || [];\n          const response = yield rp({\n            uri: `https://egghead.io/api/v1/lessons/${ lessonSlug }/next_up`,\n            json: true\n          });\n          const { lessons } = response.list || { lessons: [] };\n\n          return lessons.map(function (lesson) {\n            const pattern = /https:\\/\\/.*\\/lessons\\/.*\\/(.*)\\?.*/;\n            const [url, filename] = pattern.exec(lesson.download_url);\n            return { url, filename };\n          });\n        }\n        progress.start('Fetching lesson pages');\n        // fetch and process the lessons, start all requests at the same time to save time.\n        const promises = lessonURLs.map(processLessonURL);\n        const result = yield Promise.all(promises.map(reflect));\n        progress.stop(true);\n        // get the urls that succeded and thos that failed\n        const videoURLs = result.filter(function (v) {\n          return v.state === 'resolved';\n        }).map(function (v) {\n          return v.value;\n        });\n        const failed = result.filter(function (v) {\n          return v.state === 'rejected';\n        });\n        // check if we have some lesson pages that failed (wrong url or paid)\n        if (failed.length) {\n          error(`Failed to parse the following lesson pages: ${ failed.map(function (v) {\n            return `'${ v.value }'`;\n          }).join(',') }. They might be for pro subscribers only`, false);\n        }\n        return videoURLs;\n      }\n    } catch (e) {\n      error(`fetching the url '${ urlValue }' failed!`);\n    }\n  });\n\n  return function getVideoData() {\n    return _ref4.apply(this, arguments);\n  };\n})();\n\n// fetches the lesson page and calls parseLessonPage on it\n\n\nfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\nconst program = require('commander');\nconst pkg = require('../package.json');\nconst chalk = require('chalk');\nconst requestPromise = require('request-promise');\nconst request = require('request');\nconst PleasantProgress = require('pleasant-progress');\nconst path = require('path');\nconst fs = require('fs');\nconst inquirer = require('inquirer');\n\nlet urlValue;\nlet outputDir;\nlet isPro = false;\nconst prompt = inquirer.createPromptModule();\nconst progress = new PleasantProgress();\nconst rp = requestPromise.defaults({ jar: true });\nconst SIGN_IN_URL = 'https://egghead.io/users/sign_in';\n\nprogram.version(pkg.version).arguments('<url> [output-dir]').option('-e, --email <email>', 'Account email (only required for Pro accounts)').option('-p, --password [password]', 'Account password (only required for Pro accounts)', true).option('-c, --count', 'Add the number of the video to the filename (only for playlists and series)').option('-f, --force', 'Overwriting existing files').action((url, output) => {\n  urlValue = url;\n  outputDir = output ? path.resolve(output) : process.cwd();\n});\nprogram.parse(process.argv);\n\nif (process.argv.slice(2).length < 2) {\n  program.outputHelp();\n  process.exit();\n}\n\nif (!/egghead.io\\/(lessons|series|playlists|courses)\\//.test(urlValue)) {\n  error('unsupported url!');\n}\n\n// await is only supported in functions (with the async keyword)\ndoTheMagic();\n\nfunction fileExists(p) {\n  try {\n    return fs.statSync(p).isFile();\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction processLessonURL(url) {\n  return new Promise((() => {\n    var _ref5 = _asyncToGenerator(function* (resolve, reject) {\n      rp(url).then(function (source) {\n        const videoData = parseLessonPage(source);\n        if (videoData) {\n          resolve(videoData);\n        } else {\n          reject(url);\n        }\n      }, function () {\n        reject(url);\n      });\n    });\n\n    return function (_x3, _x4) {\n      return _ref5.apply(this, arguments);\n    };\n  })());\n}\n\n// parses the lesson page, returns the video data if found.\nfunction parseLessonPage(source) {\n  const re = /<meta itemprop=\"name\" content=\"([^\"]+?)\".+?<meta itemprop=\"contentURL\" content=\"http[^\"]+?.wistia.com\\/deliveries\\/(.+?)\\.bin\"/;\n  const result = re.exec(source);\n  if (result) {\n    return {\n      filename: result[1],\n      url: `https://embed-ssl.wistia.com/deliveries/${ result[2] }/file.mp4`\n    };\n  }\n}\n\n// creates a directory\nfunction createOutputDirectoryIfNeeded() {\n  try {\n    const stats = fs.lstatSync(outputDir);\n    if (!stats.isDirectory()) {\n      error(`Can't create the output directory '${ outputDir }' because a file with the same name exists`);\n    }\n  } catch (e) {\n    try {\n      fs.mkdirSync(outputDir);\n    } catch (err) {\n      error(`Creating the output directory '${ outputDir }' failed with error '${ err }'`);\n    }\n  }\n}\n\n// helper functions\nfunction success(message) {\n  console.log(chalk.green(message));\n}\n\nfunction error(message, exit = true) {\n  console.log(chalk.red(`Error: ${ message }`));\n  if (exit) {\n    process.exit(1);\n  }\n}\n\n// wraps a promise in another promise that resolves when the promise either resolves or rejects\nfunction reflect(promise) {\n  return promise.then(x => ({ state: 'resolved', value: x }), e => ({ state: 'rejected', value: e }));\n}\n","/home/travis/build/npmtest/node-npmtest-egghead-downloader/node_modules/egghead-downloader/src/app.js":"#! /usr/bin/env node\nconst program = require('commander')\nconst pkg = require('../package.json')\nconst chalk = require('chalk')\nconst requestPromise = require('request-promise')\nconst request = require('request')\nconst PleasantProgress = require('pleasant-progress')\nconst path = require('path')\nconst fs = require('fs')\nconst inquirer = require('inquirer')\n\nlet urlValue\nlet outputDir\nlet isPro = false\nconst prompt = inquirer.createPromptModule()\nconst progress = new PleasantProgress()\nconst rp = requestPromise.defaults({jar: true})\nconst SIGN_IN_URL = 'https://egghead.io/users/sign_in'\n\nprogram\n  .version(pkg.version)\n  .arguments('<url> [output-dir]')\n  .option('-e, --email <email>', 'Account email (only required for Pro accounts)')\n  .option('-p, --password [password]', 'Account password (only required for Pro accounts)', true)\n  .option('-c, --count', 'Add the number of the video to the filename (only for playlists and series)')\n  .option('-f, --force', 'Overwriting existing files')\n  .action((url, output) => {\n    urlValue = url\n    outputDir = output ? path.resolve(output) : process.cwd()\n  })\nprogram.parse(process.argv)\n\nif (process.argv.slice(2).length < 2) {\n  program.outputHelp()\n  process.exit()\n}\n\nif (!/egghead.io\\/(lessons|series|playlists|courses)\\//.test(urlValue)) {\n  error('unsupported url!')\n}\n\n// await is only supported in functions (with the async keyword)\ndoTheMagic()\n\nfunction fileExists (p) {\n  try {\n    return fs.statSync(p).isFile()\n  } catch (e) {\n    return false\n  }\n}\n\nasync function getCSRFToken () {\n  const body = await rp(SIGN_IN_URL)\n  const pattern = /<meta name=\"csrf-token\" content=\"(.*)\" \\/>/\n  const [, CSRFToken] = pattern.exec(body) || []\n  return CSRFToken\n}\n\nasync function authenticate (email, password) {\n  const CSRFToken = await getCSRFToken()\n  const options = {\n    method: 'POST',\n    uri: SIGN_IN_URL,\n    form: {\n      'user[email]': email,\n      'user[password]': password,\n      'authenticity_token': CSRFToken\n    },\n    simple: false,\n    resolveWithFullResponse: true\n  }\n\n  const response = await rp(options)\n\n  if (response.statusCode !== 302) {\n    throw Error('Failed to authenticate.')\n  }\n}\n\nasync function doTheMagic () {\n  if (program.email) {\n    if (program.password === true) {\n      const { password } = await prompt({\n        type: 'password',\n        name: 'password',\n        message: 'Egghead.io password'\n      })\n      program.password = password\n    }\n    try {\n      await authenticate(program.email, program.password)\n      isPro = true\n      success('Authenticated!')\n    } catch (err) {\n      return error(err)\n    }\n  }\n\n  const videos = await getVideoData()\n  if (!videos.length) {\n    error('no video found!')\n  }\n  success(`Found ${videos.length} ${(videos.length) > 1 ? 'videos' : 'video'}`)\n\n  createOutputDirectoryIfNeeded()\n\n  const padLength = String(videos.length).length\n  const padZeros = '0'.repeat(padLength)\n  let i = 0\n  for (const {url, filename} of videos) {\n    i++\n    let paddedCounter = `${padZeros}${i}`.slice(-padLength)\n    const p = path.join(outputDir, (program.count ? `${paddedCounter}-${filename}` : filename))\n    if (!program.force && fileExists(p)) {\n      console.log(`File ${paddedCounter}-${filename} already exists, skip`)\n      continue\n    }\n    progress.start(`Downloading video ${paddedCounter} out of ${videos.length}: '${filename}'`)\n    const stream = fs.createWriteStream(p)\n    await new Promise((resolve, reject) => {\n      request(url)\n        .on('error', () => {\n          error(`download of '${url}' failed!`, false)\n          reject()\n        })\n        .on('end', () => {\n          resolve()\n        })\n        .pipe(stream)\n    })\n    stream.close()\n    progress.stop(true)\n  }\n  success('Done!')\n}\n\n// loads the url and parses it, when it's playlist/serie loads the video pages\n// too, and returns an array with the video data\nasync function getVideoData () {\n  try {\n    const [, lessonSlug] = /egghead.io\\/lessons\\/([^\\?]*)/.exec(urlValue) || []\n    let source = await rp(urlValue)\n\n    if (lessonSlug) {\n      let videoData\n      success('The URL is a lesson')\n\n      if (isPro) {\n        const response = await rp({\n          uri: `https://egghead.io/api/v1/lessons/${lessonSlug}/next_up`,\n          json: true\n        })\n        const { lessons } = response.list || {lessons: []}\n\n        videoData = lessons\n          .filter((lesson) => lesson.slug === lessonSlug)\n          .map((lesson) => {\n            const pattern = /https:\\/\\/.*\\/lessons\\/.*\\/(.*)\\?.*/\n            const [url, filename] = pattern.exec(lesson.download_url)\n            return {url, filename}\n          })[0]\n      } else {\n        videoData = parseLessonPage(source)\n      }\n\n      // process the lesson page\n      if (videoData) {\n        return [videoData]\n      } else {\n        error(`failed to parse the lesson page '${urlValue}'}`)\n      }\n    } else {\n      let lessonURLs = []\n      success('The URL is a playlist or series')\n\n      // get the urls of the lessions\n      const re = /<h4 class=\"title\"><a href=\"(https:\\/\\/egghead.io\\/lessons\\/.+?)\">/g\n      // regexp in js have no matchAll method or something similiar..\n      let match\n      while ((match = re.exec(source))) {\n        lessonURLs.push(match[1])\n      }\n      success(`Found ${lessonURLs.length} ${(lessonURLs.length) > 1 ? 'lessons' : 'lesson'}`)\n\n      if (isPro) {\n        const firstLesson = lessonURLs[0]\n        const pattern = /egghead.io\\/lessons\\/(.*)\\?/\n        const [, lessonSlug] = pattern.exec(firstLesson) || []\n        const response = await rp({\n          uri: `https://egghead.io/api/v1/lessons/${lessonSlug}/next_up`,\n          json: true\n        })\n        const { lessons } = response.list || {lessons: []}\n\n        return lessons.map((lesson) => {\n          const pattern = /https:\\/\\/.*\\/lessons\\/.*\\/(.*)\\?.*/\n          const [url, filename] = pattern.exec(lesson.download_url)\n          return {url, filename}\n        })\n      }\n      progress.start('Fetching lesson pages')\n      // fetch and process the lessons, start all requests at the same time to save time.\n      const promises = lessonURLs.map(processLessonURL)\n      const result = await Promise.all(promises.map(reflect))\n      progress.stop(true)\n      // get the urls that succeded and thos that failed\n      const videoURLs = result.filter(v => (v.state === 'resolved')).map(v => v.value)\n      const failed = result.filter(v => (v.state === 'rejected'))\n      // check if we have some lesson pages that failed (wrong url or paid)\n      if (failed.length) {\n        error(`Failed to parse the following lesson pages: ${failed.map(v => `'${v.value}'`).join(',')}. They might be for pro subscribers only`, false)\n      }\n      return videoURLs\n    }\n  } catch (e) {\n    error(`fetching the url '${urlValue}' failed!`)\n  }\n}\n\n// fetches the lesson page and calls parseLessonPage on it\nfunction processLessonURL (url) {\n  return new Promise(async (resolve, reject) => {\n    rp(url).then((source) => {\n      const videoData = parseLessonPage(source)\n      if (videoData) {\n        resolve(videoData)\n      } else {\n        reject(url)\n      }\n    }, () => {\n      reject(url)\n    })\n  })\n}\n\n// parses the lesson page, returns the video data if found.\nfunction parseLessonPage (source) {\n  const re = /<meta itemprop=\"name\" content=\"([^\"]+?)\".+?<meta itemprop=\"contentURL\" content=\"http[^\"]+?.wistia.com\\/deliveries\\/(.+?)\\.bin\"/\n  const result = re.exec(source)\n  if (result) {\n    return {\n      filename: result[1],\n      url: `https://embed-ssl.wistia.com/deliveries/${result[2]}/file.mp4`\n    }\n  }\n}\n\n// creates a directory\nfunction createOutputDirectoryIfNeeded () {\n  try {\n    const stats = fs.lstatSync(outputDir)\n    if (!stats.isDirectory()) {\n      error(`Can't create the output directory '${outputDir}' because a file with the same name exists`)\n    }\n  } catch (e) {\n    try {\n      fs.mkdirSync(outputDir)\n    } catch (err) {\n      error(`Creating the output directory '${outputDir}' failed with error '${err}'`)\n    }\n  }\n}\n\n// helper functions\nfunction success (message) {\n  console.log(chalk.green(message))\n}\n\nfunction error (message, exit = true) {\n  console.log(chalk.red(`Error: ${message}`))\n  if (exit) {\n    process.exit(1)\n  }\n}\n\n// wraps a promise in another promise that resolves when the promise either resolves or rejects\nfunction reflect (promise) {\n  return promise.then(x => ({state: 'resolved', value: x}),\n    e => ({state: 'rejected', value: e}))\n}\n"}